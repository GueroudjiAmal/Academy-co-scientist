— In the past few decades, a number of user-level threading and tasking models have been proposed in the literature to address
the shortcomings of OS-level threads, primarily with respect to cost and ﬂexibility. Current state-of-the-art user-level threading and tasking
models, however, either are too speciﬁc to applications or architectures or are not as powerful or ﬂexible. In this paper, we present Argobots,
a lightweight, low-level threading and tasking framework that is designed as a portable and performant substrate for high-level programming
models or runtime systems. Argobots offers a carefully designed execution model that balancesgeneralityof functionality with providing a
rich set of controls to allowspecializationby end users or high-level programming models. We describe the design, implementation, and
performance characterization of Argobots and present integrations with three high-level models: OpenMP, MPI, and colocated I/O services.
Evaluations show that (1) Argobots, while providing richer capabilities, is competitive with existing simpler generic threading runtimes;
(2) our OpenMP runtime offers more efﬁcient interoperability capabilities than production OpenMP runtimes do; (3) when MPI interoperates
with Argobots instead of Pthreads, it enjoys reduced synchronization costs and better latency-hiding capabilities; and (4) I/O services with
Argobots reduce interference with colocated applications while achieving performance competitive with that of a Pthreads approach.
Index Terms— Argobots, user-level thread, tasklet, OpenMP, MPI, I/O, interoperability, lightweight, context switch, stackable scheduler
Ç
1I NTRODUCTION
E
FFICIENTLY supporting massive on-node parallelism
demands highly ﬂexible and lightweight threading and
tasking runtimes. OS-level threads have been long recog-
nized to be inadequate in this regard, primarily owing to
their heavy-handed approach in managing arbitration and
synchronization, as well as their inﬂexibility in adapting
to the specialization requirements of speciﬁc applications.
As a result, over the past few decades, a number of user-level
threading and tasking abstractions have emerged as more
practical alternatives.
These lightweight abstractions have successfully served
as building blocks for several parallel programming sys-
tems and applications. Current state of the art, however,
suffers from shortcomings related to how these abstractions
handle generality and specialization. Existing runtimes tai-
lored for generic use [1], [2], [3], [4], [5], [6], [7], [8], [9] are
suitable as common frameworks to facilitate portability and
interoperability but offer insufﬁcient ﬂexibility to efﬁciently
capture higher-level abstractions. This lack of ﬂexibility
often takes the form of transparent decisions on behalf of
the user that incur undesired costs or inefﬁcient resource
usage. For instance, these runtimes implement transparent
and rigid scheduling decisions (e.g., random work stealing)
that incur costs (e.g., shared thread pool accesses) and pro-
vide no guarantee for optimal scheduling. Unfortunately,
these runtimes provide little to no control to the user to
overcome these inefﬁciencies. Specialized runtimes are ori-
ented to a speciﬁc environment, for example, runtimes tar-
geted at OS task management [10], [11], network services
[12], [13], [14], compiler frameworks [15], speciﬁc hardware
[16], and parallel programming runtimes [17], [18], [19],
/C15 S. Seo, A. Amer, P. Balaji, P. Carns, and P. Beckman are with the Argonne
National Laboratory, Lemont, IL 60439.
E-mail: {sseo, aamer, balaji, carns, beckman}@anl.gov.
/C15 C. Bordage is with the Inria Bordeaux, Talence 33405, France.
E-mail: cyril.bordage@inria.fr.
/C15 A. Brooks, P. Jindal, L.V. Kal/C19e, and M. Snir are with the University of
Illinois at Urbana-Champaign, Champaign, IL 61820.
E-mail: {brooks8, jindal2, kale, snir}@illinois.edu.
/C15 G. Bosilca, D. Genet, and T. Herault are with the University of Tennessee,
Knoxville, TN 37996. E-mail: {bosilca, dgenet, herault}@icl.utk.edu.
/C15 S. Iwasaki and K. Taura are with the University of Tokyo, Bunkyo, Tokyo
113-8654, Japan. E-mail: {iwasaki, tau}@eidos.ic.i.u-tokyo.ac.jp.
/C15 A. Castell/C19o is with the Universitat Jaume I, Castell /C19on de la Plana,
Castell/C19on 12071, Spain. E-mail: adcastel@uji.es.
/C15 S. Krishnamoorthy is with the Paciﬁc Northwest National Laboratory,
Richland, WA 99354. E-mail: sriram@pnnl.gov.
/C15 J. Lifﬂander is with the Sandia National Laboratories, Livermore, CA
94551-0969. E-mail: jlifﬂ2@illinois.edu.
/C15 H. Lu is with Tencent, Shenzhen 518057, China.
E-mail: huiweilv@tencent.com.
/C15 E. Meneses is with the Costa Rica National High Technology Center, San
Jos/C19e 10109, Costa Rica, and with the Costa Rica Institute of Technology,
Cartago 30101, Costa Rica. E-mail: esteban.meneses@acm.org.
/C15 Y. Sun is with the Google, Mountain View, CA 94043.
E-mail: sun51@illinois.edu.
Manuscript received 20 Dec. 2016; revised 12 Oct. 2017; accepted 15 Oct.
2017. Date of publication 24 Oct. 2017; date of current version 9 Feb. 2018.
(Corresponding author: Sangmin Seo.)
Recommended for acceptance by D. Padua.
For information on obtaining reprints of this article, please send e-mail to:
reprints@ieee.org, and reference the Digital Object Identiﬁer below.
Digital Object Identiﬁer no. 10.1109/TPDS.2017.2766062
512 IEEE TRANSACTIONS ON PARALLEL AND DISTRIBUTED SYSTEMS, VOL. 29, NO. 3, MARCH 2018
1045-9219 /C2232017 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission.
See ht_ tp://www.ieee.org/publications_standards/publications/rights/index.html for more information.
Authorized licensed use limited to: Argonne National Laboratory. Downloaded on October 29,2025 at 20:39:10 UTC from IEEE Xplore.  Restrictions apply. 
[20]. These are heavily customized with a rich set of capabil-
ities. Such abstractions, however, are virtually unusable out-
side the target environment because they were not meant
for general use. They are often notportable (e.g., targeted to
speciﬁc hardware) and do not offer sufﬁcient user control
outside the target environment. The Intel OpenMP Run-
time [17] and Nanos++ [18], for instance, are efﬁcient back-
end runtimes for OpenMP compilers but are hardly usable
outside this scope.
We propose, in this paper, to ﬁll this gap with Argobots,
a lightweight, low-level threading and tasking framework.
Argobots not only offers a portable library interface that is
broadly applicableto a number of target domains but also pro-
vides a rich set of controls to allowspecialized runtime man-
agement by the user. The ﬁrst goal of Argobots is to expose
sufﬁcient information and capabilities for users to efﬁciently
map high-level abstractions to low-level implementations.
The second goal is to allow different software packages to
interoperate through Argobots as a lightweight substrate
instead of relying on OS-level interoperation.
Argobots honors this high degree of expressibility
through three key aspects. First, Argobots distinguishes
between the requirements of differentwork units, which are
the most basic manageable entities. Work units that require
private stacks and context-saving capabilities, referred to as
user-level threads (ULTs, also calledcoroutines or ﬁbers), are
fully ﬂedged threads usable in any context.Tasklets do not
require private stacks. They are more lightweight than
ULTs because they do not incur context saving and stack
management overheads. Tasklets, however, are restrictive;
they can be executed only as atomic work units that run to
completion without context switching. This distinction
allows users to create the work unit type that ﬁts their pur-
pose. When tasklets are sufﬁcient, performance gains over
ULTs are certain. Second, work units execute within
OS-level threads, which we refer to as execution streams
(ESs). Unlike existing generic runtimes, ESs are exposed to
and manageable by users. This added level of control offers
opportunities for afﬁnity and interoperability improve-
ments (e.g., avoiding oversubscription of OS-level threads).
Third, Argobots allows full control overwork unit manage-
ment. Users can freely manage scheduling and mapping of
work units to ESs and achieve the desired behavior.
In order to ensure fast critical paths despite the rich set of
capabilities, Argobots was designed in a modular way to offer
conﬁguration knobs and a rich API that allow users to trim
unnecessary costs. An in-depth critical path characterization
study is also provided, which involved investigating every
cache miss and translation lookaside buffer (TLB) miss that
occurs on critical paths. In a fully optimized state, Argobots
achieved unprecedented performance in the context of light-
weight runtimes. Indeed, evaluating Argobots against several
highly performing generic lightweight threading libraries,
such as Qthreads [5] and MassiveThreads [4], showed that
Argobots incurs little overhead and scales better than the
other libraries while achieving sustainable performance.
To evaluate the adequacy of Argobots as a substrate run-
time and its interoperability capabilities, we present proto-
type integrations with the most widely used programming
systems in high-performance computing (HPC)—OpenMP
and MPI—as well as a use case in colocated I/O services.
Our OpenMP runtime over Argobots avoids OS-level
thread interoperability issues that arise from nesting
OpenMP-based software. We demonstrate that OpenMP
over Argobots can scale signiﬁcantly better than existing
OpenMP runtimes with synthetic benchmarks and in a fast
multipole method (FMM) implementation that suffers from
nested parallelism when ofﬂoading computation to an
external OpenMP-based parallel library. We also show that
when interoperating with MPI, Argobots can enable
reduced synchronization costs and better latency-hiding
capabilities, compared with Pthreads. Moreover, unlike
with Pthreads, we show that I/O services ov